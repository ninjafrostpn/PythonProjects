from cv2 import fillPoly
import pygame
from pygame.locals import *
import numpy as np
import time

pygame.init()

# https://en.wikipedia.org/wiki/Rotation_matrix
# Matrix for rotating a 2D vector widdershins by angle theta
R = lambda theta: np.sin((np.float64([[0.5, 1], [0, 0.5]]) * np.pi) + theta)


# This function chops up sides until they're smaller than a certain size
def subdivide(vertices, maxlength):
    # The distance between each vertex and the previous one
    d = np.linalg.norm(vertices - [vertices[-1], *vertices[:-1]], axis=1)
    # All the sides which are longer than the maximum permitted
    cuts = np.nonzero(d > maxlength)[0]
    # The minimum number of cuts required to bring those sides down to size
    ncuts = np.int32(np.ceil(d[cuts] / maxlength))
    # Generates an array of new vertices to insert
    newverts = np.zeros((2, 0), "float64")
    for i in range(len(cuts)):
        # Interpolates xs and ys of each too-long side as required (discards end vertices, as these already exist)
        newverts = np.append(newverts, [np.linspace(vertices[cuts[i] - 1, 0], vertices[cuts[i], 0], ncuts[i])[1:-1],
                                        np.linspace(vertices[cuts[i] - 1, 1], vertices[cuts[i], 1], ncuts[i])[1:-1]],
                             axis=1)
    vertices = np.insert(vertices, np.repeat(cuts, ncuts - 2), newverts.T, axis=0)
    return vertices


w, h = 500, 250
screensize = np.int32((w, h))
screen = pygame.display.set_mode(screensize)

# If True, it tries to keep the physics up with real time, freezing when it can't catch up
# If False, it runs without regard for time, lagging behind or passing ahead of real time according to calculation speed
realtime = False
# TODO: Optimise this darned thing so that this number can be higher than 100
fps = 300
deltaT = 1 / fps

airresist = 0.999
bounciness = 0.25
gravity = 500

keys = set()

# Reference all the shapes' vertices into this array
refarray = np.zeros((100, 1000, 2), "float64")
# And this one keeps track of how many shapes there are, and have ever been
totshapes = np.int32([0, 0])
# Try method of squares for area calculation. No, really.
squaresmethod = True


class Polygon:
    # TODO: Add crushing and other functions for coolness
    def __init__(self, vertices, density=1, opensides=None, vel=(0, 0), avel=0, no=None):
        if no is None:
            self.no = totshapes[0]
            totshapes[:] += 1
        else:
            self.no = no
            totshapes[1] += 1
        self.vel = np.float64(vel)
        self.acc = np.zeros(2, "float64")
        self.ang = 0
        self.avel = avel
        self.aacc = 0
        # Define vertices convex and clockwise pls
        # This array of vertices is defined relative to centre
        self.vertices = subdivide(np.float64(vertices), 5)
        self.centre = np.mean(self.vertices, axis=0)
        self.vertices -= self.centre
        # Vectors pointing clockwise from each vertex (with a z dimension of 0
        tangents = np.float64([[*(self.vertices[(i + 1) % len(self.vertices)] - self.vertices[i]), 0]
                               for i in range(len(self.vertices))])
        # Vectors pointing outward from the side clockwise of each vertex
        self.normals = np.cross(tangents, [0, 0, 1], axisa=1)[:, :2]
        self.normals = (self.normals.T / np.linalg.norm(self.normals, axis=1)).T
        self.currnormals = self.normals.copy()
        # For convex shape, look at pairs of adjacent vertices with average of all vertices to form triangles
        # Find areas and centres of these triangles -> sum of areas * density for mass
        #                                              weighted average by [area * density] for com
        #                                              masses and areas also used to calculate inertia
        self.density = density
        areas = []
        centroids = []
        inertias = []
        # TODO: Attempt to solve issues surrounding the effects of sampling density on estimated integral
        if squaresmethod:
            # Get the bounds of the shape in its own reference frame
            minmax = np.int32([np.min(self.vertices, axis=0), np.max(self.vertices, axis=0)])
            # Create a canvas just big enough to draw it on
            q = np.zeros(minmax[1] - minmax[0] + 1)
            # Use a well-optimised cv2 method to draw it (note that x and y coordinates are reversed for drawing,
            # but that the coordinates in the array are still [x, y] for our purposes later)
            q = fillPoly(q, [(np.int32(self.vertices) - minmax[0])[:, ::-1]], 1)
            # Sum the coloured pixels for an estimate of area, multiply by density for mass
            self.area = np.sum(q)
            self.mass = self.area * self.density
            # Since all pixel areas weigh the same, average their positions relative to the old centre for the com
            qi = np.transpose(np.nonzero(q)) + minmax[0]
            centreofmass = np.mean(qi, axis=0)
            # https://en.wikipedia.org/wiki/List_of_second_moments_of_area for second moment of area of rect at corner
            # Ix = rho.b.h^3 / 3 = rho/3, Iy = rho.h.b^3 / 3 = rho/3, since h = b = 1
            # https://en.wikipedia.org/wiki/Perpendicular_axis_theorem for thin lamina
            # Therefore Iz = Ix + Iy = 2/3 . rho
            # https://www.khanacademy.org/science/physics/torque-angular-momentum/torque-tutorial/a/rotational-inertia
            # Io = Iz + m.d^2 = Iz + rho.A.d^2 = Iz + rho.(x^2 + y^2), because A = 1 and d^2 = x^2 + y^2
            self.inertia = (self.density * ((self.area * (2 / 3)) + np.sum(qi ** 2))) +\
                           (self.mass * (np.linalg.norm(centreofmass) ** 2))
        else:
            for i in range(len(self.vertices)):
                pts = np.int32([[0, 0], self.vertices[i - 1], self.vertices[i]])
                centroids.append(np.mean(pts, axis=0))
                # Triangular area from https://www.mathopenref.com/coordtrianglearea.html
                # |ax(by - cy) + bx(cy - ay) + cx(ay - by)| / 2
                areas.append(np.abs(np.sum(pts[[0, 1, 2], 0] * (pts[[1, 2, 0], 1] - pts[[2, 0, 1], 1]))) / 2)
                # https://en.wikipedia.org/wiki/List_of_second_moments_of_area
                # https://en.wikipedia.org/wiki/Perpendicular_axis_theorem
                # Ix = b.h^3 / 12, Iy = b.h.(a^2 + a.b + b^2) / 12, so Iz = b.h.(h^2 + a^2 + b^2 + a.b) / 12
                # https://www.khanacademy.org/science/physics/torque-angular-momentum/torque-tutorial/a/rotational-inertia
                # Translates to inertia at the centre: Io = Iz + m.d^2
                bt = np.linalg.norm(self.vertices[i] - self.vertices[i - 1])
                ht = np.dot(self.vertices[i - 1], self.normals[i - 1])
                at = np.linalg.norm(self.vertices[i - 1] - (self.normals[i - 1] * ht))
                inertias.append(self.density *
                                (((bt * ht * ((ht**2) + (at**2) + (bt**2) + (at * bt))) / 12) +
                                 (areas[-1] * (np.linalg.norm(self.vertices[i - 1])**2))))
            self.area = np.sum(areas)
            self.mass = density * self.area
            # Calculating centre of mass (relative to centre): https://www.youtube.com/watch?v=Px_KdmC7HlA
            centreofmass = np.sum(np.float64(centroids).T * np.float64(areas), axis=1).T / self.area
            # Translate the inertia from the separate ones at the centre to combined at the centre of mass
            self.inertia = np.sum(inertias) + (self.mass * (np.linalg.norm(centreofmass) ** 2))
        # Move the centre to the centre of mass
        self.vertices -= centreofmass
        self.centre += centreofmass
        # Make the array of current vertex positions
        self.currvertices = refarray[self.no, :len(self.vertices)]
        self.currvertices[:] = self.vertices + self.centre
        refarray[self.no, len(self.vertices):] = np.nan
        self.radius = np.max(np.linalg.norm(self.vertices, axis=1))
        print(self.mass, self.inertia, len(self.vertices), self.radius)
        # This variable will be used later for constructing concave shapes
        # if opensides is not None:
        #     self.opensides = opensides
        # else:
        #     self.opensides = []

    def checkpoints(self, points, getpen=False, getbadvals=False):
        if len(points) == 0:
            if getpen:
                return [[], [], [], []]
            return []
        # Use dot product to check if each point is inside the polygon
        # Lines up points a, b, c with sides x, y, z like
        # [a, a, a, b, b, b, c, c, c] and
        # [x, y, z, x, y, z, x, y, z] for calculations
        # Dot product for point-side pair = sum((point - vertex) * normal)
        pendepth = np.sum((np.repeat(points, len(self.currvertices), axis=0)
                           - np.tile(self.currvertices.T, len(points)).T)
                          * np.tile(self.currnormals.T, len(points)).T, axis=1).reshape(len(points), -1)
        verdict = np.all(pendepth <=0, axis=1)
        if getpen:
            # Find the side of smallest penetration depth for each point (i.e. the side they're closest to)
            # (Should this incorporate some idea of entry direction?)
            penside = np.argmax(np.minimum(pendepth, 0), axis=1)
            # And expose the smallest penetration depth (note that this is negative), or nan if none, of each point
            minpendepth = pendepth[np.arange(0, len(points)), penside]
            # Direction and magnitude of penetrations as vectors
            penvec = (self.currnormals[penside].T * minpendepth).T
            if not getbadvals:
                penside[~verdict] = -1
                minpendepth[~verdict] = np.nan
                penvec[~verdict] = np.nan
            ret = [verdict, penside, minpendepth, penvec]
            return ret
        return verdict

    def collidepolygon(self, other):
        # Method which collides the deepest-incurring point
        # TODO: Add Friction
        # TODO: Find out why big flat surfaces bounce so much and triangles speen so much
        # TODO: Find out how to stop shapes sneaking into each other at the corners
        # TODO: Perhaps try to do this part before even marking the two polygons for collision
        inmask1 = np.all((other.currvertices > np.min(self.currvertices, axis=0)) &
                         (other.currvertices < np.max(self.currvertices, axis=0)), axis=1)
        check1 = self.checkpoints(other.currvertices[inmask1], True)
        inmask2 = np.all((self.currvertices > np.min(other.currvertices, axis=0)) &
                         (self.currvertices < np.max(other.currvertices, axis=0)), axis=1)
        check2 = other.checkpoints(self.currvertices[inmask2], True)
        # print(check1[0], check2[0])
        if np.any(check1[0]) or np.any(check2[0]):
            maxpenno = np.nanargmin([*check1[2], *check2[2]])
            if maxpenno < len(check1[1]):
                maxpenside = check1[1][maxpenno]
                maxpendepth = check1[2][maxpenno]
                maxpenvec = check1[3][maxpenno]
                collpos = other.currvertices[inmask1][maxpenno] - maxpenvec
                P1 = other  # The polygon with the furthest incurring vertex
                P2 = self   # The polygon being poked by said vertex
            else:
                maxpenside = check2[1][maxpenno - len(check1[1])]
                maxpendepth = check2[2][maxpenno - len(check1[1])]
                maxpenvec = check2[3][maxpenno - len(check1[1])]
                collpos = self.currvertices[inmask2][maxpenno - len(check1[1])] - maxpenvec
                P1 = self   # The polygon with the furthest incurring vertex
                P2 = other  # The polygon being poked by said vertex
            # pygame.draw.line(screen, 255 << 16, collpos, collpos + (P2.currnormals[maxpenside] * 10))
            # Move the object to the outside
            if P1.mass == 0:
                P2.centre += maxpenvec
            elif P2.mass == 0:
                P1.centre -= maxpenvec
            else:
                P1.centre -= maxpenvec / 2
                P2.centre += maxpenvec / 2
            # https://en.wikipedia.org/wiki/Angular_velocity#Particle_in_three_dimensions
            P1collpos = collpos - P1.centre
            P2collpos = collpos - P2.centre
            P1rotvel = np.cross([0, 0, P1.avel], [*P1collpos, 0])[:2]
            P2rotvel = np.cross([0, 0, P2.avel], [*P2collpos, 0])[:2]
            relvel = P1.vel + P1rotvel - P2.vel - P2rotvel
            contactspd = np.dot(relvel, P2.currnormals[maxpenside])  # u1 (u2 is set to 0 now)
            # Don't bother with weak collisions, just cancel them
            if contactspd >= 0:
                return False
            if maxpendepth > -0.01:
                if P1.mass != 0:
                    # P1.vel = (P1.vel - (contactvel * P2.currnormals[maxpenside])) + \
                    #          (np.maximum(0, contactvel) * P2.currnormals[maxpenside])
                    P1.centre += maxpenvec
                if P2.mass != 0:
                    # P2.vel = (P2.vel + (contactvel * P2.currnormals[maxpenside])) - \
                    #          (np.maximum(0, contactvel) * P2.currnormals[maxpenside])
                    P2.centre -= maxpenvec
            if P1.mass == 0:
                # Invert the reference frame, so u2 = -u1_original, u1_new = 0
                # Rebound velocity, so v2 = -u2 = u1_original
                # v2 - u2 = 2 * u1_original
                # Get f1 by calculating -f2 (= f1)
                f1 = -((P2.mass * 2 * contactspd) / deltaT) * P2.currnormals[maxpenside]
            elif P2.mass == 0:
                # Rebound velocity, so v1 = -u1
                # v1 - u1 = -2 * u1
                f1 = -((P1.mass * 2 * contactspd) / deltaT) * P2.currnormals[maxpenside]
            else:
                finalspd = contactspd * (P1.mass - P2.mass) / (P1.mass + P2.mass)  # v1
                f1 = ((P1.mass * (finalspd - contactspd)) / deltaT) * P2.currnormals[maxpenside]
            P1.applyforce(f1 * bounciness, collpos)
            P2.applyforce(-f1 * bounciness, collpos)
            return True

    def collidepolygon2(self, other):
        # Method which collides every incurring point of each polygon
        # TODO: Add Friction
        # TODO: Find out why big flat surfaces bounce so much and triangles speen so much
        # TODO: Find out how to stop shapes sneaking into each other at the corners
        # TODO: Perhaps try to do this part before even marking the two polygons for collision
        polys = [other, self]
        inmask = [np.all((polys[k].currvertices > np.min(polys[k - 1].currvertices, axis=0)) &
                         (polys[k].currvertices < np.max(polys[k - 1].currvertices, axis=0)), axis=1)
                  for k in range(2)]
        check = [polys[k - 1].checkpoints(polys[k].currvertices[inmask[k]], True) for k in range(2)]
        f = np.zeros([0, 2], "float64")
        fpos = np.zeros([0, 2], "float64")
        for k in range(2):
            if np.any(check[k][0]):
                penside = check[k][1][check[k][0]]
                pendepth = check[k][2][check[k][0]]
                penvec = check[k][3][check[k][0]]
                maxpenvec = penvec[np.argmin(pendepth)]
                collpos = polys[k].currvertices[inmask[k]][check[k][0]] - penvec
                P1 = polys[k]  # The polygon with the furthest incurring vertex
                P2 = polys[k - 1]   # The polygon being poked by said vertex
                # Move the object to the outside
                if P1.mass == 0:
                    P2.centre += maxpenvec
                elif P2.mass == 0:
                    P1.centre -= maxpenvec
                else:
                    P1.centre -= maxpenvec / 2
                    P2.centre += maxpenvec / 2
                # https://en.wikipedia.org/wiki/Angular_velocity#Particle_in_three_dimensions
                P1collpos = collpos - P1.centre
                P2collpos = collpos - P2.centre
                P1rotvel = np.cross([0, 0, P1.avel], np.append(P1collpos, np.zeros([len(penvec), 1]), axis=1))[:, :2]
                P2rotvel = np.cross([0, 0, P2.avel], np.append(P2collpos, np.zeros([len(penvec), 1]), axis=1))[:, :2]
                relvel = P1.vel + P1rotvel - P2.vel - P2rotvel
                contactspd = np.sum(relvel * P2.currnormals[penside], axis=1)  # u1 (u2 is set to 0 now)
                # Weed out non-collisions
                hitmask = (contactspd < 0)
                if np.any(hitmask):
                    if P1.mass == 0:
                        # Invert the reference frame, so u2 = -u1_original, u1_new = 0
                        # Rebound velocity, so v2 = -u2 = u1_original
                        # v2 - u2 = 2 * u1_original
                        # Get f1 by calculating -f2 (= f1)
                        f1 = -(((P2.mass * 2 * contactspd[hitmask]) / deltaT) * P2.currnormals[penside][hitmask].T).T
                    elif P2.mass == 0:
                        # Rebound velocity, so v1 = -u1
                        # v1 - u1 = -2 * u1
                        f1 = -(((P1.mass * 2 * contactspd[hitmask]) / deltaT) * P2.currnormals[penside][hitmask].T).T
                    else:
                        finalspd = contactspd[hitmask] * (P1.mass - P2.mass) / (P1.mass + P2.mass)  # v1
                        f1 = (((P1.mass * (finalspd - contactspd[hitmask])) / deltaT)
                              * P2.currnormals[penside][hitmask].T).T
                    f = np.append(f, f1 * (-1 if k == 0 else 1), axis=0)
                    fpos = np.append(fpos, collpos[hitmask], axis=0)
        if len(f) > 0:
            self.applyforce(f * bounciness, fpos)
            other.applyforce(-f * bounciness, fpos)
            return True
        return False

    def applyforce(self, what, where=None):
        if self.mass > 0:
            what = np.float64(what)
            if len(what.shape) != 2:
                what = np.reshape(what, [-1, 2])
            if where is None:
                self.acc += np.sum(what, axis=0) / (self.mass * len(what))
            else:
                where = np.float64(where)
                if len(where.shape) != 2:
                    where = np.reshape(where, [-1, 2])
                r = where - self.centre
                # rhat = (r.T / np.linalg.norm(r, axis=1)).T
                # F = (np.sum(rhat * what, axis=1) * rhat.T).T
                # Bounciness here is a fudge that seems to work. TODO: Find out why
                T = np.cross(r, what * bounciness)
                self.acc += np.sum(what, axis=0) / (self.mass * len(what))
                self.aacc += np.sum(T) / (self.inertia * len(what))

    def update(self):
        # Positional stuff
        if self.mass != 0:
            self.acc[1] += gravity
        self.vel += self.acc * deltaT
        self.centre += self.vel * deltaT
        self.acc[:] = 0
        self.vel *= airresist
        # Angular stuff
        self.avel += self.aacc * deltaT
        self.ang += self.avel * deltaT
        self.ang %= 2 * np.pi
        self.aacc = 0
        self.avel *= airresist
        rotmat = R(self.ang)
        self.currvertices[:] = self.centre + np.dot(rotmat, self.vertices.T).T
        self.currnormals = np.dot(rotmat, self.normals.T).T

    def show(self):
        # pygame.draw.polygon(screen, 255, self.centre + self.vertices, 1)
        # print(self.currvertices.shape, self.currvertices.dtype, type(self.currvertices),
        #       np.any(np.isnan(self.currvertices)), np.nanmax(self.currvertices), self.no)
        try:
            pygame.draw.polygon(screen, 255, self.currvertices, 1)
        except TypeError:
            print("BROKE")
        # pygame.draw.line(screen, 255 << 16, self.centre, self.centre + [0, self.avel * 5])
        # pygame.draw.line(screen, 255 << 8, self.centre, self.centre + self.vel)
        # pygame.draw.circle(screen, 255 << 16, np.int32(self.centre), max(int(self.mass / 500), 1), 1)
        # for i in range(len(self.currnormals)):
        #     pygame.draw.line(screen, 255 << 8, self.currvertices[i], self.currvertices[i] + (self.currnormals[i] * 2))

    def snap(self, vertex1, vertex2):
        cv = np.copy(self.currvertices)
        shapes.remove(self)
        vertex1, vertex2 = min(vertex1, vertex2), max(vertex1, vertex2)
        shapes.insert(self.no, Polygon(cv[vertex1:vertex2 + 1], density=self.density,
                                       vel=self.vel.copy(), avel=self.avel, no=self.no))
        shapes.append(Polygon([*cv[:vertex1 + 1], *cv[vertex2:]], density=self.density,
                              vel=self.vel.copy(), avel=self.avel))

    def cut(self, vec):
        dp = np.sum((self.currvertices - self.centre) * vec, axis=1)
        side1 = np.nonzero(dp >= 0)[0]
        side2 = np.nonzero(dp < 0)[0]
        cp = np.cross(self.currvertices - self.centre, vec)
        self.snap(side1[np.argmin(np.abs(cp[side1]))], side2[np.argmin(np.abs(cp[side2]))])

    def changescale(self, factor):
        if factor != 1:
            cv = ((self.currvertices - self.centre) * factor) + self.centre
            shapes.remove(self)
            shapes.insert(self.no, Polygon(cv, density=self.density / (factor ** 2),
                                           vel=self.vel.copy(), avel=self.avel, no=self.no))


# Note to self, adding points in the middle of sides helps (stops equal-sized blocks sliding through each other)
# TODO: Implement this in Polygon code or find a better solution (doesn't stop half-sized blocks)
#       Maybe have polygons generate temporary midpoints for sake of collision

shapes = [Polygon([[0, -100], [0, h + 100], [-100, h + 100], [-100, -100]], 0),
          Polygon([[w, -100], [w + 100, -100], [w + 100, h + 100], [w, h + 100]], 0),
          Polygon([[-100, 0], [-100, -100], [w + 100, -100], [w + 100, 0]], 0),
          Polygon([[-100, h], [w + 100, h], [w + 100, h + 100], [-100, h + 100]], 0)]

n = 10
shapemode = 0
if shapemode == 0:
    shapes += [Polygon(np.random.random_sample(2) * (w - 100, h - 100) + 50 +
                       np.float64([np.sin([((t / i) + 0.25) * 2 * np.pi, (t / i) * 2 * np.pi]) * r * 10
                                   for t in range(i)]))
               for i, r in zip(np.random.randint(3, 10, n), np.random.randint(1, 6, n))]
elif shapemode == 1:
    shapes += [Polygon([w/2, i * 10] + np.float64([[-i * 20, -5], [i * 20, -5], [i * 20, 0],
                                                   [i * 20, 5], [-i * 20, 5], [-i * 20, 0]]))
               for i in range(1, n + 1)]
elif shapemode == 2:
    shapes += [Polygon([w/4, i * 20] + np.float64([[i * 20, -10], [i * 50, -10], [i * 50, 0],
                                                   [i * 50, 10], [i * 20, 10], [i * 20, 0]]))
               for i in range(1, n + 1)]
elif shapemode == 3:
    shapes += [Polygon(np.random.random_sample(2) * (w - 10, h - 10) + [[0, 0], [35, 0], [35, 35], [0, 35]])
               for i in range(n)]

if realtime:
    lastupdate = time.time()
else:
    lastupdate = -1

while True:
    if np.any(np.isnan(refarray[:, 0])):
        print("WURP")
    screen.fill(0)
    a, b = np.int32([(i, j) for i in range(len(shapes)) for j in range(len(shapes)) if j > max(i, 3)]).T
    arrowforce = (((K_RIGHT in keys) - (K_LEFT in keys)) * 2000000, ((K_DOWN in keys) - (K_UP in keys)) * 2000000)
    scalefactor = 1 + (((K_q in keys) - (K_a in keys)) / 100)
    while lastupdate < time.time():
        shapes[-1].applyforce(arrowforce)
        if scalefactor != 1:
            shapes[-1].changescale(scalefactor)
        # Leftmost, Upmost, Rightmost, Downmost reach of each Polygon (with the last one first as well)
        lurd = np.float64([[*np.nanmin(shapes[i].currvertices, axis=0), *np.nanmax(shapes[i].currvertices, axis=0)]
                           for i in range(len(shapes))])
        # Check if any bounding boxes intersect in both x and y
        possibles = (~((lurd[a, 0] > lurd[b, 2]) | (lurd[a, 2] < lurd[b, 0])) &
                     ~((lurd[a, 1] > lurd[b, 3]) | (lurd[a, 3] < lurd[b, 1])))
        possibles = np.nonzero(possibles)[0]
        # print(a[possibles], b[possibles])
        for i in possibles:
            shapes[a[i]].collidepolygon2(shapes[b[i]])
        for P in shapes:
            P.update()
        if realtime:
            lastupdate += deltaT
        else:
            break
    for P in shapes[4:]:
        P.show()
    pygame.display.flip()
    for e in pygame.event.get():
        if e.type == QUIT:
            quit()
        elif e.type == KEYDOWN:
            keys.add(e.key)
            if e.key == K_ESCAPE:
                quit()
        elif e.type == KEYUP:
            keys.discard(e.key)
            if e.key == K_SPACE:
                shapes[-1].cut([0, 1])
                # shapes[-1].snap(0, len(shapes[-1].vertices) // 2)
    # time.sleep(pygame.mouse.get_pos()[0] / w)
