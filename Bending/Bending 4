import pygame
from pygame.locals import *
import numpy as np
import time

pygame.init()

w, h = 500, 250
screensize = np.int32((w, h))
screen = pygame.display.set_mode(screensize)

fps = 200
deltaT = 1 / fps

keys = set()

polygons = []


class Polygon:
    # TODO: Add crushing and other functions for coolness
    def __init__(self, vertices, mass=None, centre=None, opensides=None):
        if mass is None:
            # TODO: Work out mass according to some density (probably combine this with the com-finder)
            self.mass = 1
        else:
            self.mass = mass
        self.vel = np.zeros(2, "float64")
        self.acc = np.zeros(2, "float64")
        # Define vertices convex and clockwise pls
        # Vertices defined relative to centre, which is here used as centre of mass
        # TODO: implement proper com-finding (see https://www.youtube.com/watch?v=Px_KdmC7HlA)
        self.vertices = np.float64(vertices)
        if centre is None:
            # You can define the com if you want to
            self.centre = np.mean(self.vertices, axis=0)
        else:
            self.centre = np.float64(centre)
        self.vertices -= self.centre
        # This variable will be used later for constructing concave shapes
        if opensides is not None:
            self.opensides = opensides
        else:
            self.opensides = []
        # Vectors pointing clockwise from each vertex (with a z dimension of 0
        tangents = np.float64([[*(self.vertices[(i + 1) % len(self.vertices)] - self.vertices[i]), 0]
                               for i in range(len(vertices))])
        # Vectors pointing outward from the side clockwise of each vertex
        self.normals = np.cross(tangents, [0, 0, 1], axisa=1)[:, :2]
        self.normals = (self.normals.T / np.linalg.norm(self.normals, axis=1)).T

    def update(self):
        if self.mass != 0:
            self.acc[1] += 100
        self.vel += self.acc * deltaT
        self.centre += self.vel * deltaT
        self.acc[:] = 0

    def checkpoints(self, points, getpen=False):
        # Use dot product to check if point is inside
        pendepth = [np.sum((pt - self.vertices - self.centre) * self.normals, axis=1)
                    for pt in points]
        verdict = np.bool_([np.all(p < 0)
                            for p in pendepth])
        # print(pendepth, verdict)
        if getpen:
            # Find the side of smallest penetration depth
            penside = np.int32([-1 if not v else np.argmax(np.minimum(p, 0))
                                for v, p in zip(verdict, pendepth)])
            # And expose the smallest penetration depth (note that this is negative), or 0 if none, of each point
            minpendepth = np.float64([0 if ps == -1 else pd[ps]
                                      for ps, pd in zip(penside, pendepth)])
            # Direction and magnitude of penetrations as vectors
            penvec = np.float64([[np.nan, np.nan] if ps == -1 else self.normals[ps] * pd
                                 for ps, pd in zip(penside, minpendepth)])
            return verdict, penside, minpendepth, penvec
        return verdict

    def collidepolygon(self, other):
        check1 = self.checkpoints(other, True)
        check2 = other.checkpoints(self, True)
        # print(check1[0], check2[0])
        if np.any(check1[0]) or np.any(check2[0]):
            maxpenno = np.nanargmin([*check1[2], *check2[2]])
            if maxpenno < len(check1):
                maxpenside = check1[1][maxpenno]
                u1 = np.dot(other.vel - self.vel, self.normals[maxpenside])  # u1 (u2 is set to 0 now)
                if u1 >= 0:
                    return False
                if other.mass == 0:
                    # Invert the reference frame, so u2 <= -u1, u1 <= 0
                    # Rebound velocity, so v2 = -u2
                    # Get f1 by calculating -f2 (= f1)
                    f1 = -((self.mass * 2 * u1) / deltaT) * self.normals[maxpenside]
                elif self.mass == 0:
                    # Rebound velocity, so v1 = -u1
                    f1 = -((other.mass * 2 * u1) / deltaT) * self.normals[maxpenside]
                else:
                    v1 = u1 * (other.mass - self.mass) / (other.mass + self.mass)
                    f1 = ((other.mass * (v1 - u1)) / deltaT) * self.normals[maxpenside]
                other.applyforce(f1 * 0.9)
                # TODO: Find collision location on side at which to apply force
                self.applyforce(-f1 * 0.9)
                return True

    def applyforce(self, what, where=None):
        if self.mass > 0:
            # TODO: Implement off-centre force application with speeeeeeen
            if where is None:
                where = self.centre
            # print(what)
            self.acc += what / self.mass

    def __iter__(self):
        return iter(self.vertices + self.centre)

    def show(self):
        pygame.draw.polygon(screen, 255, self.centre + self.vertices, 1)
        pygame.draw.circle(screen, 255, np.int32(self.centre), 3)


A = Polygon([[10, 10], [100, 10], [100, 54], [60, 100], [10, 15]])
A.vel += (100, 0)
B = Polygon([[450, 30], [470, 75], [430, 65], [420, 50]])
B.vel -= (100, 0)

Boundary = [Polygon([[0, -100], [0, h], [-100, h], [-100, -100]], 0),
            Polygon([[w, 0], [w + 100, 0], [w + 100, h + 100], [w, h + 100]], 0),
            Polygon([[0, 0], [0, -100], [w + 100, -100], [w + 100, 0]], 0),
            Polygon([[-100, h], [w, h], [w, h + 100], [-100, h + 100]], 0)]

lastupdate = time.time()

while True:
    while lastupdate < time.time():
        for P in Boundary:
            P.collidepolygon(A)
            P.collidepolygon(B)
        A.collidepolygon(B)
        A.update()
        B.update()
        for P in Boundary:
            P.update()
        lastupdate += deltaT
    screen.fill(0)
    A.show()
    B.show()
    for P in Boundary:
        P.show()
    pygame.display.flip()
    for e in pygame.event.get():
        if e.type == QUIT:
            quit()
        elif e.type == KEYDOWN:
            keys.add(e.key)
            if e.key == K_ESCAPE:
                quit()
        elif e.type == KEYUP:
            keys.discard(e.key)


# Interesting but wrong thoughts

# Vertex Inside    Outer Edge
#     [m1]            [m2]
#       o<-----ds----->|    - BEFORE (colliding, vertex past edge, inside shape)
#  u1 <--           u2 = 0   |
#      >F1>          <F2<   - CHANGE (force changes direction)
#       --> v1    v2 <--     |
#              |o           - AFTER  (separating, vertex is on edge)
# ds = v1.dt - v2.dt, where ds is the distance to separate the point from inside the
# m1.u1 + m2.u2 = m1.v1 + m2.v2, if momentum is to be conserved
# therefore, after rearranging and combining:
#     v1 = ((ds/dt) + u2 + (u1 . (m1/m2))) / (1 + (m1/m2))
# which helps to get v1, which goes into:
#     F1 = m1(v1 - u1) / dt
#        = -F2
